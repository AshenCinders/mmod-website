generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id Int @id @default(autoincrement())

  roles Int @default(0) @db.SmallInt /// Bitfield of roles.enum.ts
  bans  Int @default(0) @db.SmallInt /// Bitfield of bans.enum.ts

  /// Optional because placeholders don't have SteamIDs
  steamID BigInt? @unique(map: "user_steamID") @db.BigInt
  alias   String
  avatar  String?
  country String? @db.Char(2)

  userAuth          UserAuth?
  profile           Profile?
  userStats         UserStats?
  submittedMaps     MMap[]
  mapCredits        MapCredit[]
  mapFavorites      MapFavorite[]
  mapLibraryEntries MapLibraryEntry[]
  activities        Activity[]
  follows           Follow[]            @relation("follow_follow")
  followers         Follow[]            @relation("follow_follower")
  mapNotifies       MapNotify[]
  notifications     Notification[]
  runSessions       RunSession[]
  reportSubmitted   Report[]            @relation("report_submitter")
  reportResolved    Report[]            @relation("report_resolver")
  testingRequests   MapTestingRequest[]
  reviewsSubmitted  MapReview[]         @relation("mapreview_reviewer")
  reviewsResolved   MapReview[]         @relation("mapreview_resolver")
  reviewComments    MapReviewComment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Profile {
  bio     String @default("")
  socials Json? /// socials.model.ts

  user   User @relation(fields: [userID], references: [id], onDelete: Cascade)
  userID Int  @id

  updatedAt DateTime @updatedAt
}

model UserStats {
  totalJumps    BigInt @default(0) @db.BigInt
  totalStrafes  BigInt @default(0) @db.BigInt
  level         Int    @default(1) @db.SmallInt
  cosXP         BigInt @default(0) @db.BigInt
  mapsCompleted Int    @default(0)
  runsSubmitted Int    @default(0)

  user   User @relation(fields: [userID], references: [id], onDelete: Cascade)
  userID Int  @id
}

model Activity {
  id Int @id @default(autoincrement())

  type Int @default(0) @db.SmallInt /// activity-type.enum.ts

  /// This is used as a primary key into one of many possible tables,
  /// determined by the value of `type`.
  data BigInt @db.BigInt

  notifications Notification[]

  user   User @relation(fields: [userID], references: [id], onDelete: Cascade)
  userID Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userID])
}

model Follow {
  notifyOn Int @default(0) @db.SmallInt /// Bitfield of activity-type.enum.ts

  followed   User @relation("follow_follower", fields: [followedID], references: [id], onDelete: Cascade)
  followedID Int

  followee   User @relation("follow_follow", fields: [followeeID], references: [id], onDelete: Cascade)
  followeeID Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@id([followeeID, followedID])
}

model Notification {
  id Int @id @default(autoincrement())

  read Boolean @default(false)

  user   User @relation(fields: [userID], references: [id], onDelete: Cascade)
  userID Int

  activity   Activity @relation(fields: [activityID], references: [id], onDelete: Cascade)
  activityID Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([activityID, userID])
}

model Report {
  id Int @id @default(autoincrement())

  type              Int      @db.SmallInt /// report-type.enum.ts
  /// This is used as a primary key into one of many possible tables,
  /// determined by the value of `type`.
  data              BigInt   @db.BigInt
  category          Int      @db.SmallInt
  message           String?
  resolved          Boolean? @default(false)
  resolutionMessage String?

  submitter   User? @relation("report_submitter", fields: [submitterID], references: [id], onDelete: SetNull)
  submitterID Int?

  resolver   User? @relation("report_resolver", fields: [resolverID], references: [id], onDelete: SetNull)
  resolverID Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([resolverID, submitterID])
}

model UserAuth {
  refreshToken String?

  user   User @relation(fields: [userID], references: [id], onDelete: Cascade)
  userID Int  @id
}

/// The term 'MMap' is used to avoid collisions with the JS data structure, just
/// in cases where the exact name "Map" is used.
model MMap {
  id Int @id @default(autoincrement())

  name     String
  fileName String? // Optional as isn't set until map is approved
  status   Int     @db.SmallInt /// map-status.enum.ts
  hash     String? @db.Char(40)
  hasVmf   Boolean @default(false)
  zones    Json? /// map-zones.model.ts

  thumbnail   MapImage? @relation("mapimage_thumbnail", fields: [thumbnailID], references: [id], onDelete: SetNull)
  thumbnailID Int?      @unique

  submitter   User? @relation(fields: [submitterID], references: [id], onDelete: SetNull)
  submitterID Int?

  stats MapStats?
  info  MapInfo?

  credits         MapCredit[]
  favorites       MapFavorite[]
  images          MapImage[]
  libraryEntries  MapLibraryEntry[]
  notifies        MapNotify[]
  reviews         MapReview[]
  submission      MapSubmission?
  testingRequests MapTestingRequest[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([submitterID])
}

model MapCredit {
  type        Int     @db.SmallInt /// map-credit-type.enum.ts
  description String?

  mmap  MMap @relation(fields: [mapID], references: [id], onDelete: Cascade)
  mapID Int

  user   User @relation(fields: [userID], references: [id], onDelete: Cascade)
  userID Int

  @@id([mapID, userID])
  @@index([mapID])
}

model MapFavorite {
  id Int @id @default(autoincrement())

  mmap  MMap @relation(fields: [mapID], references: [id], onDelete: Cascade)
  mapID Int

  user   User @relation(fields: [userID], references: [id], onDelete: Cascade)
  userID Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([mapID, userID])
}

model MapImage {
  id Int @id @default(autoincrement())

  thumbnail MMap? @relation("mapimage_thumbnail")

  mmap  MMap @relation(fields: [mapID], references: [id], onDelete: Cascade)
  mapID Int

  @@index([mapID])
}

model MapInfo {
  description  String   @default("")
  youtubeID    String?
  creationDate DateTime

  mmap  MMap @relation(fields: [mapID], references: [id], onDelete: Cascade)
  mapID Int  @unique

  @@id([mapID])
}

model MapLibraryEntry {
  id Int @id @default(autoincrement())

  user   User @relation(fields: [userID], references: [id], onDelete: Cascade)
  userID Int

  mmap  MMap @relation(fields: [mapID], references: [id], onDelete: Cascade)
  mapID Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([mapID, userID])
}

model MapNotify {
  notifyOn Int @db.SmallInt /// Bitfield of activity-type.enum.ts

  mmap  MMap @relation(fields: [mapID], references: [id], onDelete: Cascade)
  mapID Int

  user   User @relation(fields: [userID], references: [id], onDelete: Cascade)
  userID Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@id([userID, mapID])
}

model MapStats {
  reviews           Int    @default(0)
  downloads         Int    @default(0)
  subscriptions     Int    @default(0)
  plays             Int    @default(0)
  favorites         Int    @default(0)
  completions       Int    @default(0)
  uniqueCompletions Int    @default(0)
  timePlayed        BigInt @default(0) @db.BigInt

  mmap  MMap @relation(fields: [mapID], references: [id], onDelete: Cascade)
  mapID Int  @id
}

model MapTestingRequest {
  mapID Int
  mmap  MMap @relation(fields: [mapID], references: [id], onDelete: Cascade)

  userID Int
  user   User @relation(fields: [userID], references: [id], onDelete: Cascade)

  state Int @db.SmallInt /// map-testing-request-state.enum.ts

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@id([mapID, userID])
}

model MapSubmission {
  mmap  MMap @relation(fields: [mapID], references: [id], onDelete: Cascade)
  mapID Int  @id

  type Int @db.SmallInt /// map-submission-type.enum.ts

  suggestions  Json  @default("[]") /// Array of map-submission-suggestions.model.ts
  placeholders Json? /// Array of map-submission-placeholder.model.ts
  dates        Json  @default("[]") /// Array of map-submission-dates.model.ts

  versions MapSubmissionVersion[]

  currentVersion   MapSubmissionVersion? @relation(name: "current_version", fields: [currentVersionID], references: [id])
  currentVersionID String?               @unique @db.Uuid
}

model MapSubmissionVersion {
  id String @id @default(uuid()) @db.Uuid // BSP file stored relative to this

  currentVersion MapSubmission? @relation(name: "current_version")

  versionNum Int     @db.SmallInt
  changelog  String?
  hash       String  @db.Char(40)
  hasVmf     Boolean @default(false)
  zones      Json? /// map-zones.model.ts

  submission   MapSubmission @relation(fields: [submissionID], references: [mapID], onDelete: Cascade)
  submissionID Int

  createdAt DateTime @default(now())

  @@index([submissionID])
}

// This model will be greatly expanded in the future to include screenshots,
// replays, savestates etc.
model MapReview {
  id Int @id @default(autoincrement())

  mainText    String
  comments    MapReviewComment[]
  suggestions Json               @default("{}") // map-submission-suggestions.model.ts
  editHistory Json? // Array of map-review-edit-history.model.ts

  mmap  MMap @relation(fields: [mapID], references: [id], onDelete: Cascade)
  mapID Int

  reviewer   User @relation(name: "mapreview_reviewer", fields: [reviewerID], references: [id], onDelete: Cascade)
  reviewerID Int

  resolved   Boolean @default(false)
  resolver   User?   @relation(name: "mapreview_resolver", fields: [resolverID], references: [id], onDelete: Cascade)
  resolverID Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([mapID])
}

model MapReviewComment {
  id Int @id @default(autoincrement())

  text String

  user   User @relation(fields: [userID], references: [id], onDelete: Cascade)
  userID Int

  review   MapReview @relation(fields: [reviewID], references: [id], onDelete: Cascade)
  reviewID Int

  createdAt DateTime @default(now())

  @@index([reviewID])
}

model RunSession {
  id BigInt @id @default(autoincrement())

  trackNum   Int                   @db.SmallInt
  zoneNum    Int                   @db.SmallInt
  timestamps RunSessionTimestamp[]

  user   User @relation(fields: [userID], references: [id], onDelete: Cascade)
  userID Int  @unique

  createdAt DateTime @default(now())

  @@index([userID])
}

model RunSessionTimestamp {
  id BigInt @id @default(autoincrement())

  zone Int @db.SmallInt
  tick Int

  session   RunSession @relation(fields: [sessionID], references: [id], onDelete: Cascade)
  sessionID BigInt

  createdAt DateTime @default(now())

  @@index([sessionID])
}

model XpSystems {
  id     Int   @id
  rankXP Json?
  cosXP  Json?
}

model DeletedSteamID {
  steamID BigInt @id @db.BigInt
}
